arbitrary write in netlink_bind: write 4 null bytes at any location

Constraints:
1. addr_len = sizeof(struct sockaddr_nl)
2. nladdr->nl_family = AF_NETLINK
3. nladdr->nl_groups = 0
4. nlk->bound = true; (this is a bool) and ensure that nladdr->nl_pid == nlk->portid.  Set these to whatever the exploit used previously for consistency.
5. nlk->netlink_bind = nullptr (this is a function pointer)

6. nlk->groups[0] != 0.  This is always true in our case because it will always be get*id()  != 0 (otherwise we are already root)

7. netlink_update_subscriptions must not crash
8. at this point, the arbwrite happens: the 4 lower bytes of *(nlk->groups) are zeroed out.
9. netlink_update_listeners must not crash

---------------------------------------------------
netlink_update_subscriptions must not crash, called as
netlink_update_subscriptions(sk, nlk->subscriptions - hweight32(nlk->groups[0]));

Best to avoid linked list manipulations done in both branches: 
need (nlk->subscriptions == 0 || subscriptions != 0) && (nlk->subscriptions != 0 || subsciptions == 0)

One way to do this is nlk->subscriptions != 0 and subscriptions != 0.  Since hweight32(nlk->groups[0]) <= 32 this is done by picking nlk->subscriptions > 32.

-------------------------------------------------------
netlink_update_listeners should not crash, called as nelink_update_listeners(sk).  There are no listeners so as long sk->sk_protocol is a valid index into nl_table this function does nothing.
