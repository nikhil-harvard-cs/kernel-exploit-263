%{
	#include <net/sock.h>
	#include <linux/fdtable.h>
%}

global enter_sys = 0;
global sockptr = 0;

probe syscall.mq_notify {
	if (execname() == "exp") {
		printf("\n\n(%d-%d) >> mq_notify(%s)\n", pid(), tid(), argstr);
		enter_sys = 1;
	}
}

probe syscall.mq_notify.return {
	if (execname() == "exp") {
		if (sockptr) {
			dump_netlink_sock(sockptr);
		}
		printf("(%d-%d) >> mq_notify(%s) = %d\n", pid(), tid(), $$parms, $return);
		enter_sys = 0;
	}
}

probe kernel.function("__fdget").return {
	if (execname() == "exp" && enter_sys == 1) {
		printf("(%d-%d) ==>> __fdget(%s) = 0x%lx\n", pid(), tid(), $$parms, $return);
	}
}

probe kernel.function("__fget").return {
	if (execname() == "exp" && enter_sys == 1) {
		printf("(%d-%d) ==>> __fget(%s) = 0x%lx\n", pid(), tid(), $$parms, $return);
	}
}

probe kernel.function("__fput").return {
	if (execname() == "exp" && enter_sys == 1) {
		printf("(%d-%d) ==>> __fput(%s)\n", pid(), tid(), $$parms);
	}
}

probe kernel.function("__alloc_skb").return {
	if (execname() == "exp" && enter_sys == 1) {
		printf("(%d-%d) ==>> __alloc_skb(%s) = 0x%lx\n", pid(), tid(), $$parms, $return);
	}
}

probe kernel.function("skb_put").return {
	if (execname() == "exp" && enter_sys == 1) {
		printf("(%d-%d) ==>> skb_put(%s) = 0x%lx\n", pid(), tid(), $$parms, $return);
	}
}

probe kernel.function("netlink_getsockbyfilp").return {
	if (execname() == "exp" && enter_sys == 1) {
		printf("(%d-%d) ==>> netlink_getsockbyfilp(%s) = 0x%lx\n", pid(), tid(), $$parms, $return);
	}
}

function dump_netlink_sock:long (arg_sock:long) %{
	unsigned long *stateptr;
	struct sock *sk = (void *)STAP_ARG_arg_sock;
	struct netlink_sock *nlk = (void *)sk;
	struct file *filep;
	
	//dump struct sk
	if (sk) {
		_stp_printf("sk = %p\n", sk);
		_stp_printf("nlk = %p\n", nlk);
		_stp_printf("sk->sk_rmem_alloc = %d\n", sk->sk_rmem_alloc);
		_stp_printf("sk->sk_rcvbuf = %p\n", sk->sk_rcvbuf);
		_stp_printf("sk->sk_refcnt = %d\n", sk->sk_refcnt);
		
		//print the file refcount for debugging
		filep = sk->sk_socket->file;
		_stp_printf("filep = %p\n", filep);
		if (filep) {
			_stp_printf("filep refcount = %d\n", filep->f_count);
		}
		
		//edit memory to trick netlink_attachskb into returning 1
		//stateptr = (unsigned long *)((unsigned long)nlk + sizeof(struct sock) + 0x20);
		//_stp_printf("(before) nlk->state = 0x%lx\n", *stateptr);
		//*stateptr |= 1;
		//_stp_printf("(after) nlk->state = 0x%lx\n", *stateptr);
		
		/*//prevent "supposed" socket write from blocking by marking the socket as  dead so that 
		_stp_printf("sk->sk_flags = 0x%x\n", sk->sk_flags);
		_stp_printf("SOCK_DEAD = 0x%x\n", SOCK_DEAD);
		sk->sk_flags |= 1 << SOCK_DEAD;
		_stp_printf("sk->sk_flags = 0x%x\n", sk->sk_flags);*/
	}
	else {
		_stp_printf("[!] sk = %p\n", sk);
	}
	
	_stp_printf("\n");
%}

/*function clear_fd_entry:long (index:long) %{
	//now null the given in the fdtable to prevent the above workaround from infinite looping
	int index = (int)STAP_ARG_index;
	struct files_struct *files = current->files;
	struct fdtable  *fdt = files_fdtable(files);
	_stp_printf("!!! NULLing entry %d in the fdtable\n", index);
	fdt->fd[3] = NULL;
%}*/

probe kernel.function("netlink_attachskb") {
	if (execname() == "exp" && enter_sys == 1) {
		printf("\n(%d-%d) ==>> netlink_attachskb(%s)\n", pid(), tid(), $$parms);
		dump_netlink_sock($sk);
		//clear_fd_entry(3);
	}
}

probe kernel.function("netlink_detachskb").return {
	if (execname() == "exp" && enter_sys == 1) {
		sockptr = $sk;
		printf("(%d-%d) ==>> netlink_detachskb(%s)\n", pid(), tid(), $$parms);
	}
}

probe kernel.function("netlink_attachskb").return {
	if (execname() == "exp" && enter_sys == 1) {
		printf("(%d-%d) ==>> netlink_attachskb(%s) = 0x%lx\n", pid(), tid(), $$parms, $return);
	}
}

/*function print_closefd_info:long (fd:long) %{
	int fd = STAP_ARG_fd; 
	 struct fdtable *fdt = files_fdtable(current->files);
	 struct file *filep = fdt->fd[fd];
	 struct socket *sock;
	 int err;
	 _stp_printf("filep = %p\n", filep);
	 if (filep) {
	 	_stp_printf("refcount for fd %d is %ld\n", fd, filep->f_count);
	 	sock = sock_from_file(filep, &err);
	 	
	 	if (sock) {
	 		_stp_printf("sk->sk_refcnt = %d\n", sock->sk->sk_refcnt);
	 	}
	 	
	 }
%}

probe kernel.function("sys_close") {
	if (execname() == "exp") {
		printf("\nBefore sys_close(%s): \n", $$parms);
		print_closefd_info($fd);
		dump_netlink_sock(sockptr);
		printf("\n");
	}
}

probe kernel.function("sys_close").return {
	if (execname() == "exp") {
		printf("After sys_close(%s) = %d: \n", $$parms, $return);
		
		print_closefd_info($fd);
		dump_netlink_sock(sockptr);
		printf("\n");
	}
}*/

