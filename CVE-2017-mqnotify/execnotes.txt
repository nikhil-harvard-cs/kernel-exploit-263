Target: netlink_attachskb must return 1.

The only branch that returns 1 requires that sk->sk_rmem_alloc > sk->sk_rcvbuf if the kernel is not out of memory.  Only sk->sk_rmem_alloc can be controlled via the netlink_skb_set_owner_r, which does "sk->sk_rmem_alloc += skb->truesize" atomically.

The code path used in the blog to call netlink_skb_owner_r is to invoke netlink_attachskb another way (as it still calls netlink_skb_set_owner_r).  This can be called from netlink_unicast, which is called from netlink_mmap_sendmsg, which is called by netlink_sendmsg, which is invoked by the sendmsg syscall.  Alternatively, netlink_sb_set_owner_r is called directly from netlink_dump, which is called by netlink_recvmsg <-- recvmsg syscall if "sk->sk_rmem_alloc <= sk->sk_rcvbuf / 2".  Investigate this later.

Triggering the code path from netlink_sendmsg: restrictions on struct msghdr * passed to it.  For reference, from include/linux/socket.h:
struct msghdr {
	void		*msg_name;	/* ptr to socket address structure */
	int		msg_namelen;	/* size of socket address structure */
	struct iov_iter	msg_iter;	/* data */
	void		*msg_control;	/* ancillary data */
	__kernel_size_t	msg_controllen;	/* ancillary data buffer length */
	unsigned int	msg_flags;	/* flags on received message */
	struct kiocb	*msg_iocb;	/* ptr to iocb for async requests */
} *msg;

struct iovec {
   void   *iov_base;  /* Starting address */
   size_t  iov_len;   /* Size of the memory pointed to by iov_base. */
};

------------------------------------------------------------------------------
In beginning of function: DECLARE_SOCKADDR(struct sockaddr_nl *, addr, msg->msg_name);

Conditions:
msg->msg_flags & MSG_OOB = 0
[pass scm_send check]: cmsg->cmsg_level from the cookie must not be SOL_SOCKET

require msg->msg_namelen != 0:
socket must have type AF_NETLINK
kernel sets dst_portid = addr->nl_pid;  //identifier of the receiver netlink socket
kernel sets dst_group = ffs(addr->nl_groups) := lsb(addr->nl_groups).  Convenient if this is 0, so that it will not be broadcast to other userspace sockets via netlink_broadcast
netlink_allowed enforces either CAP_NET_ADMIN or NL_CFG_F_NONROOT_SEND
kernel sets netlink_skb_flags |= NETLINK_SKB_DST

if (nlk->bound) {
	//check that nlk is hashed and visible
}
else {
	//autobind called initially, should work.
}
need (msg->msg_iter.nr_segs != 1) || (msg->msg_iter.iov->iov_base != NULL) to avoid error
need len <= sk->sk_sndbuf - 32

err = netlink_unicast(sk, skb, dst_portid, msg->msg_flags & MSG_DONTWAIT);
--------------------------------------------------------------------------------
netlink_unicast path:
sender and receiver port id must match: Thus the receiver must be bound first.
receiver should not be a kernel socket

------------------------------------------
plan: use sendmsg to repeatedly increment sk->sk_rmem_alloc until it is larger than sk->sk_rcvbuf.  
