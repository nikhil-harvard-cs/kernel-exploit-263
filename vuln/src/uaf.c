#include <linux/module.h>
#include <linux/uaccess.h>
#include <linux/slab.h>

#include "uaf.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("fist");

struct uaf_chunk {
	int id;
	int allocated;
	size_t size;
	struct uaf_chunk *next;
	void *data;
};
static struct uaf_chunk *uaf_head = NULL;

struct user_uaf {
	int id;
	size_t size;
	void *userptr;
};

int init_uaf(void) {
	return 0;
}

void cleanup_uaf(void) {
	if (uaf_head) {
		struct uaf_chunk *curr = uaf_head;
		struct uaf_chunk *next;
		while (curr) {
		if (curr->allocated) {
			//avoid double frees during cleanup
			kfree(curr->data);
		}
		next = curr->next;
		kfree(curr);
		curr = next;
		}
	}
}

//--------------------------------------------------------------------------

//locate uaf_chunk by id
static struct uaf_chunk *locate_uaf_chunk(int id) {
	struct uaf_chunk *probe = uaf_head;
		while (probe) {
		if (probe->id == id) {
			break;
		}
		probe = probe->next;
		}
	printk(KERN_INFO "probe = %p", (void *)probe);
	return probe;
}

//ioctl handler
long uaf_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
	int r;
	struct user_uaf user;
	printk(KERN_INFO "ioctl called");
	switch (cmd) {
		struct uaf_chunk *meta;
		case UAFALLOC:
			printk(KERN_INFO "UAFALLOC ioctl called");
			//here arg is the size of the chunk to allocate
			//allocate metadata, and then the chunk
			meta = kmalloc(sizeof(struct uaf_chunk), GFP_KERNEL);
			if (!meta) {
				return ENOMEM;
			}
			meta->data = kmalloc(arg, GFP_KERNEL);
			if (!meta->data) {
				kfree(meta);
				return ENOMEM;
			}
			
			//set metadata
			meta->allocated = 1;
			meta->size = (int)arg;
			meta->next = NULL;
			
			//get the last element of the linked list to attach the new uaf_chunk to it
			if (uaf_head) {
				struct uaf_chunk *last = uaf_head;
				while (last->next) {
					last = last->next;
				}
				last->next = meta;
				meta->id = last->id + 1;
			}
			else {
				uaf_head = meta;
				meta->id = 1;
			}
			
			return meta->id;
		
		case UAFFREE:
			printk(KERN_INFO "UAFFREE ioctl called");
			//here arg is the id of the chunk to free
			meta = locate_uaf_chunk(arg);
			if (!meta)	{
				//uaf_chunk not found
				return EINVAL;
			}
			
			//uaf_chunk found, so free probe->data.  A UAF bug exists since probe->data is not NULLed after freeing.
			if (meta->allocated) {
				//avoid double frees
				printk(KERN_INFO "freeing chunk");
				kfree(meta->data);
				meta->allocated = 0;
				return 0;
			}
			else {
				printk(KERN_INFO "meta not allocated");
				return EINVAL;
			}
			
			return 0;
		
		case UAFREAD:
			printk(KERN_INFO "UAFREAD ioctl called");
			//here arg is a (struct user_uaf *) from the user
			//get user_uaf struct from user
			r = copy_from_user(&user, (void *)arg, sizeof(struct user_uaf));
			if (r) {
				return r;
			}
			
			//copy user->size bytes from the kernel chunk to the user chunk
			//there is a UAF because meta->allocated is not being checked
			//there is an OOB read because user->size is used, not meta->size
			meta = locate_uaf_chunk(user.id);
			if (!meta) {
				return EINVAL;
			}
			r = copy_to_user(user.userptr, meta->data, user.size);
			if (r) {
				return r;
			}
			
			return 0;
	
		case UAFWRITE:
			printk(KERN_INFO "UAFWRITE ioctl called");
			//here arg is a (struct user_uaf *) from the user
			//get user_uaf struct from user
			r = copy_from_user(&user, (void *)arg, sizeof(struct user_uaf));
			if (r) {
				return r;
			}
			
			//copy user->size bytes from the user chunk to the kernel chunk
			//there is a UAF because meta->allocated is not being checked
			//there is an OOB write because user->size is used, not meta->size
			meta = locate_uaf_chunk(user.id);
			if (!meta) {
				return EINVAL;
			}
			r = copy_from_user(meta->data, user.userptr, user.size);
			if (r) {
				return r;
			}
			
			return 0;
		
		default:
			return EINVAL;
	}
}
