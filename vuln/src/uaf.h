#define UAFALLOC 0
#define UAFFREE 1
#define UAFREAD 3
#define UAFWRITE 4

struct uaf_chunk {
	int id;
	int allocated;
	size_t size;
	struct uaf_chunk *next;
	void *data;
};
struct uaf_chunk *uaf_head = NULL;

struct user_uaf {
	int id;
	size_t size;
	void *userptr;
};

static long uaf_ioctl(struct file *file, unsigned int cmd, unsigned long arg);

static int init_uaf(void) {
	return SUCCESS;
}

static void cleanup_uaf(void) {
	if (uaf_head) {
		struct uaf_chunk *curr = uaf_head;
		struct uaf_chunk *next;
		while (curr) {
		if (curr->allocated) {
			//avoid double frees during cleanup
			kfree(curr->data);
		}
		next = curr->next;
		kfree(curr);
		curr = next;
		}
	}
}

//--------------------------------------------------------------------------

//locate uaf_chunk by id
struct uaf_chunk *locate_uaf_chunk(int id) {
	struct uaf_chunk *probe = uaf_head;
		while (probe) {
		if (probe->id == id) {
			break;
		}
		probe = probe->next;
		}
	printk(KERN_INFO "probe = %p", (void *)probe);
	return probe;
}

//ioctl handler
static long uaf_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
	printk(KERN_INFO "ioctl called");
	switch (cmd) {
		struct uaf_chunk *meta;
		case UAFALLOC:
			printk(KERN_INFO "UAFALLOC ioctl called");
			//here arg is the size of the chunk to allocate
			//allocate metadata, and then the chunk
			meta = kmalloc(sizeof(struct uaf_chunk), GFP_KERNEL);
			if (!meta) {
				return ERROR;
			}
			meta->data = kmalloc(arg, GFP_KERNEL);
			if (!meta->data) {
				kfree(meta);
				return ERROR;
			}
			
			//set metadata
			meta->allocated = 1;
			meta->size = (int)arg;
			meta->next = NULL;
			
			//get the last element of the linked list to attach the new uaf_chunk to it
			if (uaf_head) {
				struct uaf_chunk *last = uaf_head;
				while (last->next) {
					last = last->next;
				}
				last->next = meta;
				meta->id = last->id + 1;
			}
			else {
				uaf_head = meta;
				meta->id = 1;
			}
			
			return meta->id;
		
		case UAFFREE:
			printk(KERN_INFO "UAFFREE ioctl called");
			//here arg is the id of the chunk to free
			meta = locate_uaf_chunk(arg);
			if (!meta)	{
				//uaf_chunk not found
				return ERROR;
			}
			
			//uaf_chunk found, so free probe->data.  A UAF bug exists since probe->data is not NULLed after freeing.
			if (meta->allocated) {
				//avoid double frees
				printk(KERN_INFO "freeing chunk");
				kfree(meta->data);
				meta->allocated = 0;
				return SUCCESS;
			}
			else {
				printk(KERN_INFO "meta not allocated");
				return ERROR;
			}
			
			return SUCCESS;
		
		struct user_uaf user;
		case UAFREAD:
			printk(KERN_INFO "UAFREAD ioctl called");
			//here arg is a (struct user_uaf *) from the user
			//get user_uaf struct from user
			if (copy_from_user(&user, (void *)arg, sizeof(struct user_uaf))) {
				return ERROR;
			}
			
			//copy user->size bytes from the kernel chunk to the user chunk
			//there is a UAF because meta->allocated is not being checked
			//there is an OOB read because user->size is used, not meta->size
			meta = locate_uaf_chunk(user.id);
			if (!meta) {
				return ERROR;
			}
			if (copy_to_user(user.userptr, meta->data, user.size)) {
				return ERROR;
			}
			
			return SUCCESS;
	
		case UAFWRITE:
			printk(KERN_INFO "UAFWRITE ioctl called");
			//here arg is a (struct user_uaf *) from the user
			//get user_uaf struct from user
			if (copy_from_user(&user, (void *)arg, sizeof(struct user_uaf))) {
				return ERROR;
			}
			
			//copy user->size bytes from the user chunk to the kernel chunk
			//there is a UAF because meta->allocated is not being checked
			//there is an OOB write because user->size is used, not meta->size
			meta = locate_uaf_chunk(user.id);
			if (!meta) {
				return ERROR;
			}
			if (copy_from_user(meta->data, user.userptr, user.size)) {
				return ERROR;
			}
			
			return SUCCESS;
		
		default:
			return ERROR;
	}
}
